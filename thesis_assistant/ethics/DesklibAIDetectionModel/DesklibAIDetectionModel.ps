{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "8cd5617c-0d75-4d93-bb96-94b27344d31d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Probability of being AI generated: 0.9974\n",
      "Predicted label: AI Generated\n",
      "Probability of being AI generated: 0.4245\n",
      "Predicted label: Not AI Generated\n"
     ]
    }
   ],
   "source": [
    "import torch\n",
    "import torch.nn as nn\n",
    "from transformers import AutoTokenizer, AutoConfig, AutoModel, PreTrainedModel\n",
    "\n",
    "class DesklibAIDetectionModel(PreTrainedModel):\n",
    "    config_class = AutoConfig\n",
    "\n",
    "    def __init__(self, config):\n",
    "        super().__init__(config)\n",
    "        # Initialize the base transformer model.\n",
    "        self.model = AutoModel.from_config(config)\n",
    "        # Define a classifier head.\n",
    "        self.classifier = nn.Linear(config.hidden_size, 1)\n",
    "        # Initialize weights (handled by PreTrainedModel)\n",
    "        self.init_weights()\n",
    "\n",
    "    def forward(self, input_ids, attention_mask=None, labels=None):\n",
    "        # Forward pass through the transformer\n",
    "        outputs = self.model(input_ids, attention_mask=attention_mask)\n",
    "        last_hidden_state = outputs[0]\n",
    "        # Mean pooling\n",
    "        input_mask_expanded = attention_mask.unsqueeze(-1).expand(last_hidden_state.size()).float()\n",
    "        sum_embeddings = torch.sum(last_hidden_state * input_mask_expanded, dim=1)\n",
    "        sum_mask = torch.clamp(input_mask_expanded.sum(dim=1), min=1e-9)\n",
    "        pooled_output = sum_embeddings / sum_mask\n",
    "\n",
    "        # Classifier\n",
    "        logits = self.classifier(pooled_output)\n",
    "        loss = None\n",
    "        if labels is not None:\n",
    "            loss_fct = nn.BCEWithLogitsLoss()\n",
    "            loss = loss_fct(logits.view(-1), labels.float())\n",
    "\n",
    "        output = {\"logits\": logits}\n",
    "        if loss is not None:\n",
    "            output[\"loss\"] = loss\n",
    "        return output\n",
    "\n",
    "def predict_single_text(text, model, tokenizer, device, max_len=768, threshold=0.5):\n",
    "    encoded = tokenizer(\n",
    "        text,\n",
    "        padding='max_length',\n",
    "        truncation=True,\n",
    "        max_length=max_len,\n",
    "        return_tensors='pt'\n",
    "    )\n",
    "    input_ids = encoded['input_ids'].to(device)\n",
    "    attention_mask = encoded['attention_mask'].to(device)\n",
    "\n",
    "    model.eval()\n",
    "    with torch.no_grad():\n",
    "        outputs = model(input_ids=input_ids, attention_mask=attention_mask)\n",
    "        logits = outputs[\"logits\"]\n",
    "        probability = torch.sigmoid(logits).item()\n",
    "\n",
    "    label = 1 if probability >= threshold else 0\n",
    "    return probability, label\n",
    "\n",
    "def main():\n",
    "    # --- Model and Tokenizer Directory ---\n",
    "    model_directory = \"desklib/ai-text-detector-v1.01\"\n",
    "\n",
    "    # --- Load tokenizer and model ---\n",
    "    tokenizer = AutoTokenizer.from_pretrained(model_directory)\n",
    "    model = DesklibAIDetectionModel.from_pretrained(model_directory)\n",
    "\n",
    "    # --- Set up device ---\n",
    "    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n",
    "    model.to(device)\n",
    "\n",
    "    # --- Example Input text ---\n",
    "    text_ai = \"AI detection refers to the process of identifying whether a given piece of content, such as text, images, or audio, has been generated by artificial intelligence. This is achieved using various machine learning techniques, including perplexity analysis, entropy measurements, linguistic pattern recognition, and neural network classifiers trained on human and AI-generated data. Advanced AI detection tools assess writing style, coherence, and statistical properties to determine the likelihood of AI involvement. These tools are widely used in academia, journalism, and content moderation to ensure originality, prevent misinformation, and maintain ethical standards. As AI-generated content becomes increasingly sophisticated, AI detection methods continue to evolve, integrating deep learning models and ensemble techniques for improved accuracy.\"\n",
    "    text_human = \"It is estimated that a major part of the content in the internet will be generated by AI / LLMs by 2025. This leads to a lot of misinformation and credibility related issues. That is why if is important to have accurate tools to identify if a content is AI generated or human written\"\n",
    "\n",
    "    # --- Run prediction ---\n",
    "    probability, predicted_label = predict_single_text(text_ai, model, tokenizer, device)\n",
    "    print(f\"Probability of being AI generated: {probability:.4f}\")\n",
    "    print(f\"Predicted label: {'AI Generated' if predicted_label == 1 else 'Not AI Generated'}\")\n",
    "\n",
    "    probability, predicted_label = predict_single_text(text_human, model, tokenizer, device)\n",
    "    print(f\"Probability of being AI generated: {probability:.4f}\")\n",
    "    print(f\"Predicted label: {'AI Generated' if predicted_label == 1 else 'Not AI Generated'}\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6d86f657-cf8f-48c9-b297-d043603c5b4f",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3.10 (GPU)",
   "language": "python",
   "name": "rl-gpu"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.18"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
